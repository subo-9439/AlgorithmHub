/* https://tech.kakao.com/posts/610
3번방법 사용 유무에 따라 변경됨 -> 즉 가운데 공유삼각형을 사용가능한가

a[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우의 수 //끝지점이 무조건 마름모
b[k] = k번째 아래 방향 정삼각형까지 덮되, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우의 수
*/
class Solution {
    public int solution(int n, int[] tops) {
        int mod = 10007;
        int[] a = new int[n];
        int[] b = new int[n];
        
        a[0] = 1; //top이 있든없든 무조건 한가지경우뿐
        b[0] = tops[0] == 0 ? 2 : 3;
        
        for (int i = 1; i < n; i++) {
            a[i] = (a[i-1] + b[i-1]) % mod; //탑이 있든 없든, 항상 이전 경우의 총합
            
            if(tops[i] == 1){
                //탑이 있을경우
                //이전에 3번을 사용하고 있는 경우의 수 -> a[i-1]
                //// 상하마름모+삼각형 , 삼각형3 -> 총경우의 수 2 => 2*a[i-1]
                //이전에 3번을 사용하지 않는 경우의 수 -> b[i-1]
                //// 상하마름모+삼각형, 삼각형3, 좌측마름모+삼각형 -> 총경우의 수 3 => 3*b[i-1]
                b[i] = (2*a[i-1] + 3*b[i-1]) % mod;
            } else {
                //탑이 없을경우
                //이전에 3번을 사용하고 있는 경우의 수 -> a[i-1]
                //// 삼각형2 -> 총경우의 수 1 => a[i-1] 
                //이전에 3번을 사용하지 않는 경우의 수 -> b[i-1]
                //// 좌측마름모+삼각형, 삼각형3 -> 총 경우의 수 2 => 2*b[i-1]
                b[i] = (a[i-1] + 2*b[i-1]) % mod;
            }
            
        }
        return (a[n-1] + b[n-1]) % mod;
    }
}